## Python语言进阶

### 重要知识点

- 生成式（推导式）的用法

  ```Python
  prices = {
      'AAPL': 191.88,
      'GOOG': 1186.96,
      'IBM': 149.24,
      'ORCL': 48.44,
      'ACN': 166.89,
      'FB': 208.09,
      'SYMC': 21.29
  }
  # 用股票价格大于100元的股票构造一个新的字典
  prices2 = {key: value for key, value in prices.items() if value > 100}
  print(prices2)
  ```

  > 说明：生成式（推导式）可以用来生成列表、集合和字典。

- 嵌套的列表的坑

  ```Python
  names = ['关羽', '张飞', '赵云', '马超', '黄忠']
  courses = ['语文', '数学', '英语']
  # 录入五个学生三门课程的成绩
  # 错误 - 参考http://pythontutor.com/visualize.html#mode=edit
  # scores = [[None] * len(courses)] * len(names)
  scores = [[None] * len(courses) for _ in range(len(names))]
  for row, name in enumerate(names):
      for col, course in enumerate(courses):
          scores[row][col] = float(input(f'请输入{name}的{course}成绩: '))
          print(scores)
  ```

  [Python Tutor](http://pythontutor.com/) - VISUALIZE CODE AND GET LIVE HELP

- `heapq`模块（堆排序）

  ```Python
  """
  从列表中找出最大的或最小的N个元素
  堆结构(大根堆/小根堆)
  """
  import heapq
  
  list1 = [34, 25, 12, 99, 87, 63, 58, 78, 88, 92]
  list2 = [
      {'name': 'IBM', 'shares': 100, 'price': 91.1},
      {'name': 'AAPL', 'shares': 50, 'price': 543.22},
      {'name': 'FB', 'shares': 200, 'price': 21.09},
      {'name': 'HPQ', 'shares': 35, 'price': 31.75},
      {'name': 'YHOO', 'shares': 45, 'price': 16.35},
      {'name': 'ACME', 'shares': 75, 'price': 115.65}
  ]
  print(heapq.nlargest(3, list1))
  print(heapq.nsmallest(3, list1))
  print(heapq.nlargest(2, list2, key=lambda x: x['price']))
  print(heapq.nlargest(2, list2, key=lambda x: x['shares']))
  ```

- `itertools`模块

  ```Python
  """
  迭代工具模块
  """
  import itertools
  
  # 产生ABCD的全排列
  itertools.permutations('ABCD')
  # 产生ABCDE的五选三组合
  itertools.combinations('ABCDE', 3)
  # 产生ABCD和123的笛卡尔积
  itertools.product('ABCD', '123')
  # 产生ABC的无限循环序列
  itertools.cycle(('A', 'B', 'C'))
  ```

- `collections`模块

  常用的工具类：

  - `namedtuple`：命令元组，它是一个类工厂，接受类型的名称和属性列表来创建一个类。
  - `deque`：双端队列，是列表的替代实现。Python中的列表底层是基于数组来实现的，而deque底层是双向链表，因此当你需要在头尾添加和删除元素是，deque会表现出更好的性能，渐近时间复杂度为$O(1)$。
  - `Counter`：`dict`的子类，键是元素，值是元素的计数，它的`most_common()`方法可以帮助我们获取出现频率最高的元素。`Counter`和`dict`的继承关系我认为是值得商榷的，按照CARP原则，`Counter`跟`dict`的关系应该设计为关联关系更为合理。
  - `OrderedDict`：`dict`的子类，它记录了键值对插入的顺序，看起来既有字典的行为，也有链表的行为。
  - `defaultdict`：类似于字典类型，但是可以通过默认的工厂函数来获得键对应的默认值，相比字典中的`setdefault()`方法，这种做法更加高效。

  ```Python
  """
  找出序列中出现次数最多的元素
  """
  from collections import Counter
  
  words = [
      'look', 'into', 'my', 'eyes', 'look', 'into', 'my', 'eyes',
      'the', 'eyes', 'the', 'eyes', 'the', 'eyes', 'not', 'around',
      'the', 'eyes', "don't", 'look', 'around', 'the', 'eyes',
      'look', 'into', 'my', 'eyes', "you're", 'under'
  ]
  counter = Counter(words)
  print(counter.most_common(3))
  ```

### 数据结构和算法

- 算法：解决问题的方法和步骤

- 评价算法的好坏：渐近时间复杂度和渐近空间复杂度。

- 渐近时间复杂度的大O标记：
  - <img src="http://latex.codecogs.com/gif.latex?O(c)" /> - 常量时间复杂度 - 布隆过滤器 / 哈希存储
  - <img src="http://latex.codecogs.com/gif.latex?O(log_2n)" /> - 对数时间复杂度 - 折半查找（二分查找）
  - <img src="http://latex.codecogs.com/gif.latex?O(n)" /> - 线性时间复杂度 - 顺序查找 / 计数排序
  - <img src="http://latex.codecogs.com/gif.latex?O(n*log_2n)" /> - 对数线性时间复杂度 - 高级排序算法（归并排序、快速排序）
  - <img src="http://latex.codecogs.com/gif.latex?O(n^2)" /> - 平方时间复杂度 - 简单排序算法（选择排序、插入排序、冒泡排序）
  - <img src="http://latex.codecogs.com/gif.latex?O(n^3)" /> - 立方时间复杂度 - Floyd算法 / 矩阵乘法运算
  - <img src="http://latex.codecogs.com/gif.latex?O(2^n)" /> - 几何级数时间复杂度 - 汉诺塔
  - <img src="http://latex.codecogs.com/gif.latex?O(n!)" /> - 阶乘时间复杂度 - 旅行经销商问题 - NPC

  ![](./res/algorithm_complexity_1.png)

  ![](./res/algorithm_complexity_2.png)

- 排序算法（选择、冒泡和归并）和查找算法（顺序和折半）


#### 简单选择排序

每⼀趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列。n个元素的简单选择排序需要 n-1 趟处理

![](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/PicGo/054f4e46c2d54897b07c8252a5f3803a.gif)

![](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/PicGo/20230417160956.png)


  ```Python
  def select_sort(items, comp=lambda x, y: x < y):
      """简单选择排序
      """
      items = items[:]
      for i in range(len(items) - 1):
          min_index = i
          for j in range(i + 1, len(items)):
              if comp(items[j], items[min_index]):
                  min_index = j
          items[i], items[min_index] = items[min_index], items[i]
      return items
  ```

#### 冒泡排序

冒泡排序是一种交换排序算法，主要是序列中的相邻元素之间比较和位置交换，这会导致序列中小（大）的元素慢慢的“浮向”序列的右端，从而导致序列降序（升序），就像水中的气泡一样，所以称为“冒泡排序”。

1. 取无序的序列中的第一个和第二个元素比较，将其中较大的排在右边，较小的排在左边。 比较序列中的第二个和第三个，将其中较大的排在右边，较小的排在左边。类推后面的元素。 比较倒数第二个和倒数第一个，将其中较大的排在右边，较小的排在左边。由此会导致序列中的最大值放在了序列的最后。

2. 将除最后元素的序列作为一个新的序列，重复步骤1导致序列中的最大值放到序列倒数第二个元素。以此类推即可。直到新的序列中只有一个元素，即可得到一个升序的序列。

![](https://liuchenmaths-1256826619.cos.ap-nanjing.myqcloud.com/PicGo/20210509190446264.gif)

时间复杂度：最坏情况：O(N^2)  
      最好情况：O(N)  
空间复杂度：O(1)

冒泡排序是稳定性排序（是否稳定性参照排序前后，相同元素的相对位置是否发生变化），由于相同的元素，并不会交换位置，所以冒泡排序是稳定的。

  ```Python
  def bubble_sort(items, comp=lambda x, y: x > y):
      """冒泡排序"""
      items = items[:]
      for i in range(len(items) - 1):
          swapped = False
          for j in range(len(items) - 1 - i):
              if comp(items[j], items[j + 1]):
                  items[j], items[j + 1] = items[j + 1], items[j]
                  swapped = True
          if not swapped:
              break
      return items
  ```

  ```Python
  def bubble_sort(items, comp=lambda x, y: x > y):
      """搅拌排序(冒泡排序升级版)"""
      items = items[:]
      for i in range(len(items) - 1):
          swapped = False
          for j in range(len(items) - 1 - i):
              if comp(items[j], items[j + 1]):
                  items[j], items[j + 1] = items[j + 1], items[j]
                  swapped = True
          if swapped:
              swapped = False
              for j in range(len(items) - 2 - i, i, -1):
                  if comp(items[j - 1], items[j]):
                      items[j], items[j - 1] = items[j - 1], items[j]
                      swapped = True
          if not swapped:
              break
      return items
  ```

#### 归并排序

1. 概念  
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法，归并排序对序列的元素进行逐层折半分组，然后从最小分组开始比较排序，合并成一个大的分组，逐层进行，最终所有的元素都是有序的

2. 算法原理  
[归并排序的算法原理](https://blog.csdn.net/qq_35344198/article/details/106857042?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168171259016800184155369%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168171259016800184155369&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-106857042-null-null.142^v83^insert_down38,239^v2^insert_chatgpt&utm_term=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&spm=1018.2226.3001.4187)

3. 归并排序算法特点

1.时间复杂度  
归并排序算法每次将序列折半分组，共需要logn轮，因此归并排序算法的时间复杂度是O(nlogn)
 
2.空间复杂度  
归并排序算法排序过程中需要额外的一个序列去存储排序后的结果，所占空间是n，因此空间复杂度为O(n)

3.稳定性  
归并排序算法在排序过程中，相同元素的前后顺序并没有改变，所以归并排序是一种稳定排序算法


  ```Python
  def merge(items1, items2, comp=lambda x, y: x < y):
      """合并(将两个有序的列表合并成一个有序的列表)"""
      items = []
      index1, index2 = 0, 0
      while index1 < len(items1) and index2 < len(items2):
          if comp(items1[index1], items2[index2]):
              items.append(items1[index1])
              index1 += 1
          else:
              items.append(items2[index2])
              index2 += 1
      items += items1[index1:]
      items += items2[index2:]
      return items
  
  
  def merge_sort(items, comp=lambda x, y: x < y):
      return _merge_sort(list(items), comp)
  
  
  def _merge_sort(items, comp):
      """归并排序"""
      if len(items) < 2:
          return items
      mid = len(items) // 2
      left = _merge_sort(items[:mid], comp)
      right = _merge_sort(items[mid:], comp)
      return merge(left, right, comp)
  ```

  ```Python
  def seq_search(items, key):
      """顺序查找"""
      for index, item in enumerate(items):
          if item == key:
              return index
      return -1
  ```

  ```Python
  def bin_search(items, key):
      """折半查找"""
      start, end = 0, len(items) - 1
      while start <= end:
          mid = (start + end) // 2
          if key > items[mid]:
              start = mid + 1
          elif key < items[mid]:
              end = mid - 1
          else:
              return mid
      return -1
  ```

- 常用算法：

  - 穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。
  - 贪婪法 - 在对问题求解时，总是做出在当前看来
  - 最好的选择，不追求最优解，快速找到满意解。
  - 分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。
  - 回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。
  - 动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。

  穷举法例子：百钱百鸡和五人分鱼。

  ```Python
  # 公鸡5元一只 母鸡3元一只 小鸡1元三只
  # 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只
  for x in range(20):
      for y in range(33):
          z = 100 - x - y
          if 5 * x + 3 * y + z // 3 == 100 and z % 3 == 0:
              print(x, y, z)
  
  # A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉
  # 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份
  # B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份
  # 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼
  fish = 6
  while True:
      total = fish
      enough = True
      for _ in range(5):
          if (total - 1) % 5 == 0:
              total = (total - 1) // 5 * 4
          else:
              enough = False
              break
      if enough:
          print(fish)
          break
      fish += 5
  ```

  贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。

  |  名称  | 价格（美元） | 重量（kg） |
  | :----: | :----------: | :--------: |
  |  电脑  |     200      |     20     |
  | 收音机 |      20      |     4      |
  |   钟   |     175      |     10     |
  |  花瓶  |      50      |     2      |
  |   书   |      10      |     1      |
  |  油画  |      90      |     9      |

  ```Python
  """
  贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。
  输入：
  20 6
  电脑 200 20
  收音机 20 4
  钟 175 10
  花瓶 50 2
  书 10 1
  油画 90 9
  """
  class Thing(object):
      """物品"""
  
      def __init__(self, name, price, weight):
          self.name = name
          self.price = price
          self.weight = weight
  
      @property
      def value(self):
          """价格重量比"""
          return self.price / self.weight
  
  
  def input_thing():
      """输入物品信息"""
      name_str, price_str, weight_str = input().split()
      return name_str, int(price_str), int(weight_str)
  
  
  def main():
      """主函数"""
      max_weight, num_of_things = map(int, input().split())
      all_things = []
      for _ in range(num_of_things):
          all_things.append(Thing(*input_thing()))
      all_things.sort(key=lambda x: x.value, reverse=True)
      total_weight = 0
      total_price = 0
      for thing in all_things:
          if total_weight + thing.weight <= max_weight:
              print(f'小偷拿走了{thing.name}')
              total_weight += thing.weight
              total_price += thing.price
      print(f'总价值: {total_price}美元')
  
  
  if __name__ == '__main__':
      main()
  ```

  分治法例子：[快速排序](https://zh.wikipedia.org/zh/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)。

  ```Python
  """
  快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大
  """
  def quick_sort(items, comp=lambda x, y: x <= y):
      items = list(items)[:]
      _quick_sort(items, 0, len(items) - 1, comp)
      return items
  
  
  def _quick_sort(items, start, end, comp):
      if start < end:
          pos = _partition(items, start, end, comp)
          _quick_sort(items, start, pos - 1, comp)
          _quick_sort(items, pos + 1, end, comp)
  
  
  def _partition(items, start, end, comp):
      pivot = items[end]
      i = start - 1
      for j in range(start, end):
          if comp(items[j], pivot):
              i += 1
              items[i], items[j] = items[j], items[i]
      items[i + 1], items[end] = items[end], items[i + 1]
      return i + 1
  ```

  回溯法例子：[骑士巡逻](https://zh.wikipedia.org/zh/%E9%AA%91%E5%A3%AB%E5%B7%A1%E9%80%BB)。

  ```Python
  """
  递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。
  """
  import sys
  import time
  
  SIZE = 5
  total = 0
  
  
  def print_board(board):
      for row in board:
          for col in row:
              print(str(col).center(4), end='')
          print()
  
  
  def patrol(board, row, col, step=1):
      if row >= 0 and row < SIZE and \
          col >= 0 and col < SIZE and \
          board[row][col] == 0:
          board[row][col] = step
          if step == SIZE * SIZE:
              global total
              total += 1
              print(f'第{total}种走法: ')
              print_board(board)
          patrol(board, row - 2, col - 1, step + 1)
          patrol(board, row - 1, col - 2, step + 1)
          patrol(board, row + 1, col - 2, step + 1)
          patrol(board, row + 2, col - 1, step + 1)
          patrol(board, row + 2, col + 1, step + 1)
          patrol(board, row + 1, col + 2, step + 1)
          patrol(board, row - 1, col + 2, step + 1)
          patrol(board, row - 2, col + 1, step + 1)
          board[row][col] = 0
  
  
  def main():
      board = [[0] * SIZE for _ in range(SIZE)]
      patrol(board, SIZE - 1, SIZE - 1)
  
  
  if __name__ == '__main__':
      main()
  ```

  动态规划例子：子列表元素之和的最大值。

  > 说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：
  >
  > 输入：1 -2 3 5 -3 2
  >
  > 输出：8
  >
  > 输入：0 -2 3 5 -1 2
  >
  > 输出：9
  >
  > 输入：-9 -2 -3 -5 -3
  >
  > 输出：-2

  ```Python
  def main():
      items = list(map(int, input().split()))
      overall = partial = items[0]
      for i in range(1, len(items)):
          partial = max(items[i], partial + items[i])
          overall = max(partial, overall)
      print(overall)
  
  
  if __name__ == '__main__':
      main()
  ```

  > **说明**：这个题目最容易想到的解法是使用二重循环，但是代码的时间性能将会变得非常的糟糕。使用动态规划的思想，仅仅是多用了两个变量，就将原来$O(N^2)$复杂度的问题变成了$O(N)$。

### 函数的使用方式

- 将函数视为“一等公民”

  - 函数可以赋值给变量
  - 函数可以作为函数的参数
  - 函数可以作为函数的返回值

- 高阶函数的用法（`filter`、`map`以及它们的替代品）

  ```Python
  items1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2, range(1, 10))))
  items2 = [x ** 2 for x in range(1, 10) if x % 2]
  ```

- #### 位置参数、可变参数、关键字参数、命名关键字参数  
在Python中，有几种不同类型的函数参数可以用于定义函数的参数列表。这些参数类型包括位置参数、可变参数、关键字参数和命名关键字参数。下面对每种参数类型进行详细解释：

1. 位置参数（Positional Arguments）：位置参数是函数定义中按照顺序出现的参数，调用函数时需要按照相同的顺序传递对应的参数值。位置参数是最常见的参数类型。

   示例：
   ```python
   def greet(name, age):
       print(f"Hello, {name}! You are {age} years old.")

   greet("Alice", 25)
   ```

   在上述示例中，`name` 和 `age` 是位置参数，函数 `greet` 的调用时，我们按照顺序传递了两个参数值 `"Alice"` 和 `25`。

2. 可变参数（Variable Length Arguments）：可变参数允许传递不定数量的参数给函数。在函数定义中，可变参数使用 `*args` 的形式表示，可以接收任意数量的位置参数，这些参数将被组装成一个元组。

   示例：
   ```python
   def calculate_sum(*args):
       total = sum(args)
       print(f"The sum is: {total}")

   calculate_sum(1, 2, 3, 4, 5)
   ```

   在上述示例中，`*args` 是可变参数，函数 `calculate_sum` 的调用时，我们传递了多个位置参数 `1, 2, 3, 4, 5`，这些参数将被组装成一个元组 `(1, 2, 3, 4, 5)`。

3. 关键字参数（Keyword Arguments）：关键字参数允许按照参数名进行传递，而不是按照位置顺序。在函数定义中，关键字参数使用 `**kwargs` 的形式表示，可以接收任意数量的关键字参数，这些参数将被组装成一个字典。

   示例：
   ```python
   def show_info(name, age, **kwargs):
       print(f"Name: {name}")
       print(f"Age: {age}")
       for key, value in kwargs.items():
           print(f"{key.capitalize()}: {value}")

   show_info(name="Alice", age=25, city="New York", occupation="Engineer")
   ```

   在上述示例中，`**kwargs` 是关键字参数，函数 `show_info` 的调用时，我们使用关键字参数按照参数名传递了额外的信息，这些参数将被组装成一个字典 `{'city': 'New York', 'occupation': 'Engineer'}`。

4. 命名关键字参数（Named Keyword Arguments）：命名关键字参数要求在函数调用时，传递参数时必须使用参数名进行传递。在函数定义中，命名关键字参数通过在位置参数之后使用 `*` 分隔符来定义。

   示例：
   ```python
   def greet(name, *, age):
       print(f"Hello, {name}! You are {age} years old.")

   greet("Alice", age=25)
   ```

   在上述示例中，`age` 是命名关键字参数，函数 `greet` 的调用时，我们使用参数名 `age` 进行传递，而不是根据位置顺序。这种方式强制要求使用参数名进行传递，提高了代码的可读性和可维护性。

请注意，这些参数类型可以在函数定义中灵活地组合使用，以满足不同的需求。在函数定义和函数调用时，正确使用这些参数类型可以提高代码的可读性、灵活性和可扩展性。

- #### 参数的元信息（代码可读性问题）
参数的元信息是指在函数定义中对参数进行注释或说明的信息，用于提供更多的描述性和可读性，帮助他人理解参数的用途、预期类型、默认值等。在代码编写中，良好的参数元信息可以提高代码的可读性和可维护性。

以下是一些常见的参数元信息的方式：

1. 参数注释（Parameter Annotations）：在函数定义的参数列表中，使用 `:` 后面的表达式为参数添加注释，用于说明参数的类型或其他相关信息。

   示例：
   ```python
   def greet(name: str, age: int = 0) -> None:
       print(f"Hello, {name}! You are {age} years old.")

   greet("Alice", 25)
   ```

   在上述示例中，`name: str` 和 `age: int = 0` 是参数的注释，它们说明了参数 `name` 的类型为字符串，参数 `age` 的类型为整数，并且 `age` 参数有一个默认值为 0。注释不会影响参数的实际行为，但可以为阅读代码的人提供更多的信息。

2. 参数说明（Parameter Description）：在函数定义的参数后面，使用文档字符串（Docstring）或单行注释的方式为参数添加描述性的说明，用于介绍参数的用途、含义、预期值等。

   示例：
   ```python
   def greet(name, age=0):
       """
       Greet the person with the given name and age.
       - `name`: The name of the person.
       - `age`: The age of the person (default is 0).
       """
       print(f"Hello, {name}! You are {age} years old.")

   greet("Alice", 25)
   ```

   在上述示例中，函数 `greet` 的文档字符串中的注释为参数 `name` 和 `age` 提供了说明，包括参数的用途和默认值。

通过添加参数的元信息，可以提供更多的上下文和解释，帮助其他开发者理解函数的参数，并正确使用和调用函数。这样可以提高代码的可读性、可维护性和可扩展性，使代码更易于理解和维护。同时，一些集成开发环境（IDE）也可以利用参数的元信息来提供自动补全、类型检查等功能，进一步提升开发效率和代码质量。

- #### 匿名函数和内联函数的用法（`lambda`函数）
匿名函数，也称为lambda函数，是一种在代码中内联定义的函数，它可以在需要函数对象的地方使用，并且通常只在定义的地方被调用一次。lambda函数的语法简洁，它可以用于编写简单的函数，而无需显式地定义函数名称。

lambda函数的语法形式如下：

```python
lambda arguments: expression
```

其中：
- `lambda` 是关键字，用于表示创建一个lambda函数。
- `arguments` 是函数的参数列表，可以是零个或多个参数，用逗号分隔。
- `expression` 是一个表达式，表示lambda函数的返回值。

下面是一些使用lambda函数的常见用法：

1. 简单函数：用lambda函数表示一个简单的函数，无需显式定义函数名称。

   示例：
   ```python
   add = lambda x, y: x + y
   print(add(2, 3))  # 输出: 5
   ```

   在上述示例中，lambda函数定义了一个加法函数，并将其赋值给变量 `add`。我们可以直接调用lambda函数并传递参数来进行加法运算。

2. 函数作为参数：lambda函数可以作为其他函数的参数，用于定义简短的回调函数。

   示例：
   ```python
   numbers = [1, 2, 3, 4, 5]
   squared = list(map(lambda x: x ** 2, numbers))
   print(squared)  # 输出: [1, 4, 9, 16, 25]
   ```

   在上述示例中，lambda函数作为 `map()` 函数的参数，用于将列表 `numbers` 中的每个元素进行平方操作。

3. 条件表达式：lambda函数可以用于编写简短的条件表达式，用于在一行代码中实现简单的逻辑。

   示例：
   ```python
   is_even = lambda x: x % 2 == 0
   print(is_even(4))  # 输出: True
   ```

   在上述示例中，lambda函数定义了一个判断奇偶性的函数，我们可以直接调用lambda函数来判断一个数是否为偶数。

需要注意的是，lambda函数通常适用于一些简单、短小的函数，不宜过于复杂。如果函数逻辑较为复杂或函数体较长，建议使用常规的函数定义来提高代码的可读性和可维护性。此外，lambda函数的使用也应遵循代码可读性和维护性的原则，确保代码的清晰和易于理解。

- #### 闭包和作用域问题

闭包和作用域是Python中重要的概念，它们关系到变量的可见性和生命周期。下面对闭包和作用域进行详细解释：

1. 作用域（Scope）：作用域指的是在程序中访问和操作变量的可见性和有效性的范围。在Python中，有以下几种作用域：
   - 局部作用域（Local Scope）：局部作用域是在函数内部定义的变量的作用域，只能在函数内部访问。局部作用域在函数执行时创建，在函数执行结束后销毁。
   - 嵌套作用域（Enclosing Scope）：嵌套作用域是指函数中嵌套的函数所定义的变量的作用域。嵌套作用域在内部函数被定义时创建，在内部函数被调用时销毁。
   - 全局作用域（Global Scope）：全局作用域是在模块层级定义的变量的作用域，可以在整个模块内访问。全局作用域在模块被导入时创建，在程序结束后销毁。
   - 内置作用域（Built-in Scope）：内置作用域是Python解释器内置的函数和对象的作用域，可以在任何地方访问。

   Python会根据作用域规则来查找和解析变量，按照局部作用域、嵌套作用域、全局作用域和内置作用域的顺序进行查找。当在某个作用域找到变量时，就会使用该变量；如果在当前作用域找不到变量，则会继续向上一级作用域查找。

2. 闭包（Closure）：闭包是指在函数内部定义的函数，并且内部函数引用了外部函数的变量。通过闭包，内部函数可以访问和操作外部函数的变量，即使外部函数已经执行完毕，这些变量依然存在于内部函数的环境中。闭包使得函数可以捕获并记住在其词法作用域之外定义的状态。

   示例：
   ```python
   def outer_func(x):
       def inner_func(y):
           return x + y
       return inner_func

   add_five = outer_func(5)
   result = add_five(3)
   print(result)  # 输出: 8
   ```

   在上述示例中，`outer_func` 是外部函数，`inner_func` 是内部函数。内部函数 `inner_func` 引用了外部函数 `outer_func` 的参数 `x`。当调用 `outer_func(5)` 后，返回了一个闭包函数 `inner_func`，并将参数 `x` 设置为 5。之后，调用 `add_five(3)` 时，闭包函数仍然可以访问和使用外部函数的变量 `x`，实现了变量的记忆效果。

闭包在函数式编程中非常有用，可以用于实现函数的柯里化、缓存、装饰器等功能。通过使用闭包，可以将代码的状态和逻辑封装在函数内部，提供更灵活和可复用的代码结构。

了解闭包和作用域的概念可以帮助开发者更好地理解和设计程序，确保变量的可见性和生命周期的合理性。同时，合理使用闭包和作用域可以提高代码的可维护性和代码块的封装性。

- #### 函数的柯里化

函数的柯里化（Currying）是一种将多参数函数转换为一系列单参数函数的技术。它基于函数的部分应用（Partial Application）概念，通过逐步传递函数的参数，每次返回一个新函数来实现。

柯里化的目的是将一个接受多个参数的函数转换为一系列接受单个参数的函数，这样可以更灵活地使用函数，简化函数的调用方式，提高代码的可读性和可复用性。

下面是一个示例来说明函数的柯里化：

```python
def add(x):
    def add_inner(y):
        return x + y
    return add_inner

add_five = add(5)
result = add_five(3)
print(result)  # 输出: 8
```

在上述示例中，我们定义了一个多参数的函数 `add`，它接受一个参数 `x`，并返回一个内部函数 `add_inner`。内部函数 `add_inner` 接受另一个参数 `y`，并返回 `x + y` 的结果。

通过调用 `add(5)`，我们得到了一个柯里化函数 `add_five`，它将参数 `x` 设置为 5。然后，我们可以使用 `add_five(3)` 来传递另一个参数 `y`，得到结果 8。

函数的柯里化可以通过不断地传递参数，逐步形成一个新的函数，使得函数的调用更加灵活。柯里化函数可以方便地生成特定参数的函数，并可以在不同的上下文中使用。

柯里化函数可以通过多种方式实现，包括使用闭包、装饰器或库函数。在Python中，可以使用 `functools` 模块中的 `partial` 函数来实现函数的柯里化。

以下是使用 `functools.partial` 实现函数的柯里化的示例：

```python
from functools import partial

def add(x, y):
    return x + y

add_five = partial(add, 5)
result = add_five(3)
print(result)  # 输出: 8
```

在上述示例中，我们使用 `partial` 函数将 `add` 函数的第一个参数 `x` 设置为 5，得到一个柯里化函数 `add_five`。然后，我们可以使用 `add_five(3)` 来传递第二个参数 `y`，得到结果 8。

通过使用柯里化，我们可以更方便地创建和使用特定参数的函数，使代码更具可读性和可复用性。

- #### 装饰器函数（使用装饰器和取消装饰器）

装饰器函数（Decorator Functions）是Python中一种特殊的函数，用于扩展或修改其他函数的行为。装饰器函数允许在不修改被装饰函数源代码的情况下，为函数添加额外的功能、行为或修饰。

装饰器函数的语法形式如下：

```python
def decorator_func(original_func):
    def wrapper_func(*args, **kwargs):
        # 添加额外的功能或行为
        result = original_func(*args, **kwargs)
        # 可选的后处理操作
        return result
    return wrapper_func
```

在上述示例中，`decorator_func` 是装饰器函数，它接受一个函数 `original_func` 作为参数，并返回一个内部函数 `wrapper_func`。内部函数 `wrapper_func` 包裹了原始函数 `original_func`，在执行原始函数之前或之后可以添加额外的功能或行为。

要将装饰器应用于函数，可以使用 `@` 符号将装饰器函数放置在被装饰函数的定义之前：

```python
@decorator_func
def some_func():
    # 函数体
```

在上述示例中，`some_func` 是被装饰的函数，我们通过 `@decorator_func` 将装饰器函数 `decorator_func` 应用于 `some_func`。

装饰器函数可以用于实现许多功能，例如：
- 记录日志：可以在装饰器中添加日志记录的逻辑，用于记录函数的调用信息。
- 计时器：可以在装饰器中添加计时的逻辑，用于统计函数的执行时间。
- 输入验证：可以在装饰器中添加输入验证的逻辑，用于验证函数的参数是否满足要求。
- 缓存结果：可以在装饰器中添加结果缓存的逻辑，用于避免重复计算。
- 权限控制：可以在装饰器中添加权限控制的逻辑，用于限制函数的访问权限。

通过使用装饰器函数，我们可以将这些功能从原始函数中分离出来，使得代码更具模块化和可维护性。装饰器可以应用于任意函数，并可以嵌套使用多个装饰器，以实现更复杂的功能组合。

  例子：输出函数执行时间的装饰器。

  ```Python
  def record_time(func):
      """自定义装饰函数的装饰器"""
      
      @wraps(func)
      def wrapper(*args, **kwargs):
          start = time()
          result = func(*args, **kwargs)
          print(f'{func.__name__}: {time() - start}秒')
          return result
          
      return wrapper
  ```
##### 参数化的装饰器
参数化的装饰器是指可以接受额外参数的装饰器。普通的装饰器在使用时不接受任何参数，只是通过装饰器语法将其应用于函数。而参数化的装饰器允许在使用装饰器时传递额外的参数，这些参数可以用于配置装饰器的行为。

参数化的装饰器通常采用两层嵌套函数的形式，其中外层函数用于接受额外的参数，并返回内层装饰器函数。内层装饰器函数则负责接收被装饰函数，并添加额外的功能。

下面是一个简单的示例来说明参数化装饰器的概念：

```python
def parameterized_decorator(param):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # 添加额外的功能或行为，使用参数 param
            result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator
```

在上述示例中，`parameterized_decorator` 是外层函数，它接受一个参数 `param`。然后，它返回一个内层装饰器函数 `decorator`。内层装饰器函数 `decorator` 接受被装饰函数，并返回一个包装函数 `wrapper`。

通过这种方式，我们可以在使用装饰器时传递额外的参数 `param`，这些参数可以在装饰器内部的 `wrapper` 函数中使用。这样可以根据传递的参数定制装饰器的行为，实现更加灵活和可配置的装饰器功能。

示例用法：
```python
@parametrized_decorator("some_parameter")
def some_function():
    # 函数体
```

在上述示例中，我们使用 `@parameterized_decorator("some_parameter")` 来应用参数化装饰器，并传递额外的参数 `"some_parameter"`。装饰器可以根据传递的参数在函数执行前后添加额外的功能。

参数化的装饰器提供了一种灵活的方式，可以通过参数来配置装饰器的行为，使得装饰器可以适应不同的需求和场景。这样可以增加装饰器的可复用性和扩展性。

  如果装饰器不希望跟`print`函数耦合，可以编写可以参数化的装饰器。

  ```Python
  from functools import wraps
  from time import time
  
  
  def record(output):
      """可以参数化的装饰器"""
  	
  	def decorate(func):
  		
  		@wraps(func)
  		def wrapper(*args, **kwargs):
  			start = time()
  			result = func(*args, **kwargs)
  			output(func.__name__, time() - start)
  			return result
              
  		return wrapper
  	
  	return decorate
  ```

  ```Python
  from functools import wraps
  from time import time
  
  
  class Record():
      """通过定义类的方式定义装饰器"""
  
      def __init__(self, output):
          self.output = output
  
      def __call__(self, func):
  
          @wraps(func)
          def wrapper(*args, **kwargs):
              start = time()
              result = func(*args, **kwargs)
              self.output(func.__name__, time() - start)
              return result
  
          return wrapper
  ```

  > **说明**：由于对带装饰功能的函数添加了@wraps装饰器，可以通过`func.__wrapped__`方式获得被装饰之前的函数或类来取消装饰器的作用。

  例子：用装饰器来实现单例模式。

  ```Python
  from functools import wraps
  
  
  def singleton(cls):
      """装饰类的装饰器"""
      instances = {}
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  
  
  @singleton
  class President:
      """总统(单例类)"""
      pass
  ```

  > **提示**：上面的代码中用到了闭包（closure），不知道你是否已经意识到了。还没有一个小问题就是，上面的代码并没有实现线程安全的单例，如果要实现线程安全的单例应该怎么做呢？

  线程安全的单例装饰器。

  ```Python
  from functools import wraps
  from threading import RLock
  
  
  def singleton(cls):
      """线程安全的单例装饰器"""
      instances = {}
      locker = RLock()
  
      @wraps(cls)
      def wrapper(*args, **kwargs):
          if cls not in instances:
              with locker:
                  if cls not in instances:
                      instances[cls] = cls(*args, **kwargs)
          return instances[cls]
  
      return wrapper
  ```

  > **提示**：上面的代码用到了`with`上下文语法来进行锁操作，因为锁对象本身就是上下文管理器对象（支持`__enter__`和`__exit__`魔术方法）。在`wrapper`函数中，我们先做了一次不带锁的检查，然后再做带锁的检查，这样做比直接加锁检查性能要更好，如果对象已经创建就没有必须再去加锁而是直接返回该对象就可以了。

### 面向对象相关知识

- 三大支柱：封装、继承、多态

  例子：工资结算系统。

  ```Python
  """
  月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成
  """
  from abc import ABCMeta, abstractmethod
  
  
  class Employee(metaclass=ABCMeta):
      """员工(抽象类)"""
  
      def __init__(self, name):
          self.name = name
  
      @abstractmethod
      def get_salary(self):
          """结算月薪(抽象方法)"""
          pass
  
  
  class Manager(Employee):
      """部门经理"""
  
      def get_salary(self):
          return 15000.0
  
  
  class Programmer(Employee):
      """程序员"""
  
      def __init__(self, name, working_hour=0):
          self.working_hour = working_hour
          super().__init__(name)
  
      def get_salary(self):
          return 200.0 * self.working_hour
  
  
  class Salesman(Employee):
      """销售员"""
  
      def __init__(self, name, sales=0.0):
          self.sales = sales
          super().__init__(name)
  
      def get_salary(self):
          return 1800.0 + self.sales * 0.05
  
  
  class EmployeeFactory:
      """创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）"""
  
      @staticmethod
      def create(emp_type, *args, **kwargs):
          """创建员工"""
          all_emp_types = {'M': Manager, 'P': Programmer, 'S': Salesman}
          cls = all_emp_types[emp_type.upper()]
          return cls(*args, **kwargs) if cls else None
  
  
  def main():
      """主函数"""
      emps = [
          EmployeeFactory.create('M', '曹操'), 
          EmployeeFactory.create('P', '荀彧', 120),
          EmployeeFactory.create('P', '郭嘉', 85), 
          EmployeeFactory.create('S', '典韦', 123000),
      ]
      for emp in emps:
          print(f'{emp.name}: {emp.get_salary():.2f}元')
  
  
  if __name__ == '__main__':
      main()
  ```

- 类与类之间的关系

在面向对象编程中，类与类之间可以通过不同的关系进行连接和交互。以下是一些常见的类与类之间的关系：

1. 关联关系（Association）：两个类之间的关系，表示它们之间有某种联系或依赖。关联关系是一种较为松散的关系，其中一个类的对象可以使用另一个类的对象，但彼此之间没有强制性的依赖。关联关系可以是单向的或双向的。

2. 聚合关系（Aggregation）：一种强关联关系，表示整体和部分之间的关系。其中一个类是另一个类的容器或集合，它们之间具有包含关系。被聚合的类可以独立存在，即使整体不存在，它们也可以存在。

3. 组合关系（Composition）：一种更强的关联关系，表示整体由部分组成，并且部分的生命周期与整体密切相关。整体对象拥有部分对象，并且控制其创建、使用和销毁。整体不存在时，部分也不存在。

4. 继承关系（Inheritance）：一种通过继承机制建立的类与类之间的关系，用于实现代码的重用和扩展。子类继承父类的属性和方法，并可以在此基础上添加新的属性和方法。继承关系创建了类的层次结构。

5. 实现关系（Implementation）：表示一个类实现了一个接口或抽象类的约定。实现关系用于描述类与接口或抽象类之间的关系，确保类具有接口或抽象类中定义的方法和行为。

6. 依赖关系（Dependency）：表示一个类在某些方面依赖于另一个类。依赖关系通常体现在一个类的方法中使用了另一个类的对象作为参数或局部变量。

这些关系描述了不同类之间的连接和交互方式，它们反映了现实世界中事物之间的关系和依赖。理解类与类之间的关系对于设计和编写面向对象的程序非常重要，它有助于建立合理的类结构和模块化设计，提高代码的可维护性和可扩展性。

  例子：扑克游戏。

  ```Python
  """
  经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择
  """
  from enum import Enum, unique
  
  import random
  
  
  @unique
  class Suite(Enum):
      """花色"""
  
      SPADE, HEART, CLUB, DIAMOND = range(4)
  
      def __lt__(self, other):
          return self.value < other.value
  
  
  class Card():
      """牌"""
  
      def __init__(self, suite, face):
          """初始化方法"""
          self.suite = suite
          self.face = face
  
      def show(self):
          """显示牌面"""
          suites = ['♠︎', '♥︎', '♣︎', '♦︎']
          faces = ['', 'A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']
          return f'{suites[self.suite.value]}{faces[self.face]}'
  
      def __repr__(self):
          return self.show()
  
  
  class Poker():
      """扑克"""
  
      def __init__(self):
          self.index = 0
          self.cards = [Card(suite, face)
                        for suite in Suite
                        for face in range(1, 14)]
  
      def shuffle(self):
          """洗牌（随机乱序）"""
          random.shuffle(self.cards)
          self.index = 0
  
      def deal(self):
          """发牌"""
          card = self.cards[self.index]
          self.index += 1
          return card
  
      @property
      def has_more(self):
          return self.index < len(self.cards)
  
  
  class Player():
      """玩家"""
  
      def __init__(self, name):
          self.name = name
          self.cards = []
  
      def get_one(self, card):
          """摸一张牌"""
          self.cards.append(card)
  
      def sort(self, comp=lambda card: (card.suite, card.face)):
          """整理手上的牌"""
          self.cards.sort(key=comp)
  
  
  def main():
      """主函数"""
      poker = Poker()
      poker.shuffle()
      players = [Player('东邪'), Player('西毒'), Player('南帝'), Player('北丐')]
      while poker.has_more:
          for player in players:
                  player.get_one(poker.deal())
      for player in players:
          player.sort()
          print(player.name, end=': ')
          print(player.cards)
  
  
  if __name__ == '__main__':
      main()
  ```

  > **说明**：上面的代码中使用了Emoji字符来表示扑克牌的四种花色，在某些不支持Emoji字符的系统上可能无法显示。

- #### 对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆）

对象的复制是指创建一个新的对象，该对象具有与原始对象相同的属性和值。在Python中，有两种类型的对象复制：浅复制（shallow copy）和深复制（deep copy）。

浅复制（浅拷贝/影子克隆）是指创建一个新的对象，新对象的属性和值与原始对象相同，但是对于可变对象（例如列表、字典等），新对象的引用仍然指向原始对象的相应对象。换句话说，浅复制只复制对象的顶层内容，而不会递归地复制对象内部的可变对象。在浅复制中，新对象和原始对象共享相同的内存空间。

深复制（深拷贝/深度克隆）是指创建一个新的对象，并递归地复制原始对象及其所有嵌套对象的内容。深复制会创建一个全新的对象，并将原始对象及其内部的可变对象一起复制到新对象中。这意味着新对象和原始对象是完全独立的，它们拥有自己的内存空间。

在Python中，可以使用`copy`模块提供的函数来进行对象复制：

- `copy.copy()`用于浅复制对象。
- `copy.deepcopy()`用于深复制对象。

下面是一个示例，展示了浅复制和深复制的区别：

```python
import copy

# 原始列表
original_list = [[1, 2, 3], [4, 5, 6]]

# 浅复制
shallow_copy = copy.copy(original_list)

# 修改原始列表的第一个元素
original_list[0][0] = 9

# 打印浅复制后的列表
print(shallow_copy)  # 输出: [[9, 2, 3], [4, 5, 6]]

# 深复制
deep_copy = copy.deepcopy(original_list)

# 修改原始列表的第一个元素
original_list[0][0] = 1

# 打印深复制后的列表
print(deep_copy)  # 输出: [[9, 2, 3], [4, 5, 6]]
```

在上述示例中，我们创建了一个原始列表`original_list`，它包含了两个子列表。然后，我们进行了浅复制和深复制，并对原始列表的第一个元素进行了修改。结果显示，浅复制后的列表也受到了修改的影响，而深复制后的列表则保持了原始值不变。

需要注意的是，对象的复制方式取决于对象的类型和嵌套结构。对于简单的对象（例如整数、字符串等），浅复制和深复制没有太大的区别。但对于复杂的对象，特别是包含嵌套可变对象的对象，要根据实际需求选择适当的复制方式。

- #### 垃圾回收、循环引用和弱引用

  Python使用了自动化内存管理，这种管理机制以**引用计数**为基础，同时也引入了**标记-清除**和**分代收集**两种机制为辅的策略。

  ```C
  typedef struct _object {
      /* 引用计数 */
      int ob_refcnt;
      /* 对象指针 */
      struct _typeobject *ob_type;
  } PyObject;
  ```

  ```C
  /* 增加引用计数的宏定义 */
  #define Py_INCREF(op)   ((op)->ob_refcnt++)
  /* 减少引用计数的宏定义 */
  #define Py_DECREF(op) \ //减少计数
      if (--(op)->ob_refcnt != 0) \
          ; \
      else \
          __Py_Dealloc((PyObject *)(op))
  ```

  导致引用计数+1的情况：

  - 对象被创建，例如`a = 23`
  - 对象被引用，例如`b = a`
  - 对象被作为参数，传入到一个函数中，例如`f(a)`
  - 对象作为一个元素，存储在容器中，例如`list1 = [a, a]`

  导致引用计数-1的情况：

  - 对象的别名被显式销毁，例如`del a`
  - 对象的别名被赋予新的对象，例如`a = 24`
  - 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）
  - 对象所在的容器被销毁，或从容器中删除对象

  引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。

  ```Python
  # 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收
  # 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效
  # 如果不想造成循环引用可以使用弱引用
  list1 = []
  list2 = [] 
  list1.append(list2)
  list2.append(list1)
  ```

  以下情况会导致垃圾回收：

  - 调用`gc.collect()`
  - `gc`模块的计数器达到阀值
  - 程序退出

  如果循环引用中两个对象都定义了`__del__`方法，`gc`模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的`__del__`方法，这个问题在Python 3.6中得到了解决。

  也可以通过`weakref`模块构造弱引用的方式来解决循环引用的问题。

- 魔法属性和方法（请参考《Python魔法方法指南》）

魔法属性和方法是Python中一些具有特殊命名约定的属性和方法，它们用于实现特定的行为或功能。它们以双下划线（`__`）开头和结尾，因此也被称为双下划线方法或双下划线属性。

以下是一些常见的魔法属性和方法：

1. `__init__`: 初始化方法，在创建对象时自动调用。用于设置对象的初始状态和属性。

2. `__str__`: 字符串表示方法，返回对象的字符串表示。通常用于打印对象或转换对象为字符串时调用。

3. `__repr__`: 用于返回对象的可打印字符串表示，通常是一个可以用来创建该对象的表达式。在交互式环境中，直接输入对象名后按下回车键时会调用该方法。

4. `__len__`: 返回对象的长度，通常用于支持内置函数`len()`。

5. `__getitem__`: 获取对象的索引值对应的元素，通常用于支持索引操作。

6. `__setitem__`: 设置对象的索引值对应的元素，通常用于支持索引赋值操作。

7. `__getattr__`: 当访问对象的属性不存在时调用，用于动态返回属性值。

8. `__setattr__`: 当给对象的属性赋值时调用，用于动态设置属性。

9. `__delattr__`: 当删除对象的属性时调用，用于动态删除属性。

10. `__call__`: 允许将对象作为函数进行调用，类似于函数调用。

11. `__iter__`: 返回一个迭代器对象，用于支持对象的迭代操作。

这只是一小部分常见的魔法属性和方法，Python中还有许多其他的魔法属性和方法，用于实现各种特殊的行为和功能。

通过使用魔法属性和方法，我们可以自定义对象的行为，使其具有更多的功能和灵活性。这为我们提供了强大的工具，可以根据需求定制对象的行为，并与Python语言和内置函数进行良好的集成。

  有几个小问题请大家思考：

  - 自定义的对象能不能使用运算符做运算？
  - 自定义的对象能不能放到`set`中？能去重吗？
  - 自定义的对象能不能作为`dict`的键？
  - 自定义的对象能不能使用上下文语法？

- 混入（Mixin）

  例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。

  ```Python
  class SetOnceMappingMixin:
      """自定义混入类"""
      __slots__ = ()
  
      def __setitem__(self, key, value):
          if key in self:
              raise KeyError(str(key) + ' already set')
          return super().__setitem__(key, value)
  
  
  class SetOnceDict(SetOnceMappingMixin, dict):
      """自定义字典"""
      pass
  
  
  my_dict= SetOnceDict()
  try:
      my_dict['username'] = 'jackfrued'
      my_dict['username'] = 'hellokitty'
  except KeyError:
      pass
  print(my_dict)
  ```

- 元编程和元类

  对象是通过类创建的，类是通过元类创建的，元类提供了创建类的元信息。所有的类都直接或间接的继承自`object`，所有的元类都直接或间接的继承自`type`。

  例子：用元类实现单例模式。

  ```Python
  import threading
  
  
  class SingletonMeta(type):
      """自定义元类"""
  
      def __init__(cls, *args, **kwargs):
          cls.__instance = None
          cls.__lock = threading.RLock()
          super().__init__(*args, **kwargs)
  
      def __call__(cls, *args, **kwargs):
          if cls.__instance is None:
              with cls.__lock:
                  if cls.__instance is None:
                      cls.__instance = super().__call__(*args, **kwargs)
          return cls.__instance
  
  
  class President(metaclass=SingletonMeta):
      """总统(单例类)"""
      
      pass
  ```

- 面向对象设计原则

  - 单一职责原则 （**S**RP）- 一个类只做该做的事情（类的设计要高内聚）
  - 开闭原则 （**O**CP）- 软件实体应该对扩展开发对修改关闭
  - 依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）
  - 里氏替换原则（**L**SP） - 任何时候可以用子类对象替换掉父类对象
  - 接口隔离原则（**I**SP）- 接口要小而专不要大而全（Python中没有接口的概念）
  - 合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码
  - 最少知识原则（迪米特法则，Lo**D**）- 不要给没有必然联系的对象发消息

  > **说明**：上面加粗的字母放在一起称为面向对象的**SOLID**原则。

- GoF设计模式

  - 创建型模式：单例、工厂、建造者、原型
  - 结构型模式：适配器、门面（外观）、代理
  - 行为型模式：迭代器、观察者、状态、策略

  例子：可插拔的哈希算法（策略模式）。

  ```Python
  class StreamHasher():
      """哈希摘要生成器"""
  
      def __init__(self, alg='md5', size=4096):
          self.size = size
          alg = alg.lower()
          self.hasher = getattr(__import__('hashlib'), alg.lower())()
  
      def __call__(self, stream):
          return self.to_digest(stream)
  
      def to_digest(self, stream):
          """生成十六进制形式的摘要"""
          for buf in iter(lambda: stream.read(self.size), b''):
              self.hasher.update(buf)
          return self.hasher.hexdigest()
  
  def main():
      """主函数"""
      hasher1 = StreamHasher()
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher1.to_digest(stream))
      hasher2 = StreamHasher('sha1')
      with open('Python-3.7.6.tgz', 'rb') as stream:
          print(hasher2(stream))
  
  
  if __name__ == '__main__':
      main()
  ```

### 迭代器和生成器

- 迭代器是实现了迭代器协议的对象。

  - Python中没有像`protocol`或`interface`这样的定义协议的关键字。
  - Python中用魔术方法表示协议。
  - `__iter__`和`__next__`魔术方法就是迭代器协议。

  ```Python
  class Fib(object):
      """迭代器"""
      
      def __init__(self, num):
          self.num = num
          self.a, self.b = 0, 1
          self.idx = 0
     
      def __iter__(self):
          return self
  
      def __next__(self):
          if self.idx < self.num:
              self.a, self.b = self.b, self.a + self.b
              self.idx += 1
              return self.a
          raise StopIteration()
  ```

- 生成器是语法简化版的迭代器。

  ```Python
  def fib(num):
      """生成器"""
      a, b = 0, 1
      for _ in range(num):
          a, b = b, a + b
          yield a
  ```

- 生成器进化为协程。

  生成器对象可以使用`send()`方法发送数据，发送的数据会成为生成器函数中通过`yield`表达式获得的值。这样，生成器就可以作为协程使用，协程简单的说就是可以相互协作的子程序。

  ```Python
  def calc_avg():
      """流式计算平均值"""
      total, counter = 0, 0
      avg_value = None
      while True:
          value = yield avg_value
          total, counter = total + value, counter + 1
          avg_value = total / counter
  
  
  gen = calc_avg()
  next(gen)
  print(gen.send(10))
  print(gen.send(20))
  print(gen.send(30))
  ```

### 并发编程

Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。

- 多线程：Python中提供了`Thread`类并辅以`Lock`、`Condition`、`Event`、`Semaphore`和`Barrier`。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。

  ```Python
  """
  面试题：进程和线程的区别和联系？
  进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程
  线程 - 操作系统分配CPU的基本单位
  并发编程（concurrent programming）
  1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行
  2. 改善用户体验 - 让耗时间的操作不会造成程序的假死
  """
  import glob
  import os
  import threading
  
  from PIL import Image
  
  PREFIX = 'thumbnails'
  
  
  def generate_thumbnail(infile, size, format='PNG'):
      """生成指定图片文件的缩略图"""
  	file, ext = os.path.splitext(infile)
  	file = file[file.rfind('/') + 1:]
  	outfile = f'{PREFIX}/{file}_{size[0]}_{size[1]}.{ext}'
  	img = Image.open(infile)
  	img.thumbnail(size, Image.ANTIALIAS)
  	img.save(outfile, format)
  
  
  def main():
      """主函数"""
  	if not os.path.exists(PREFIX):
  		os.mkdir(PREFIX)
  	for infile in glob.glob('images/*.png'):
  		for size in (32, 64, 128):
              # 创建并启动线程
  			threading.Thread(
  				target=generate_thumbnail, 
  				args=(infile, (size, size))
  			).start()
  			
  
  if __name__ == '__main__':
  	main()
  ```

  多个线程竞争资源的情况。

  ```Python
  """
  多线程程序如果没有竞争资源处理起来通常也比较简单
  当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱
  说明：临界资源就是被多个线程竞争的资源
  """
  import time
  import threading
  
  from concurrent.futures import ThreadPoolExecutor
  
  
  class Account(object):
      """银行账户"""
  
      def __init__(self):
          self.balance = 0.0
          self.lock = threading.Lock()
  
      def deposit(self, money):
          # 通过锁保护临界资源
          with self.lock:
              new_balance = self.balance + money
              time.sleep(0.001)
              self.balance = new_balance
  
  
  class AddMoneyThread(threading.Thread):
      """自定义线程类"""
  
      def __init__(self, account, money):
          self.account = account
          self.money = money
          # 自定义线程的初始化方法中必须调用父类的初始化方法
          super().__init__()
  
      def run(self):
          # 线程启动之后要执行的操作
          self.account.deposit(self.money)
  
  def main():
      """主函数"""
      account = Account()
      # 创建线程池
      pool = ThreadPoolExecutor(max_workers=10)
      futures = []
      for _ in range(100):
          # 创建线程的第1种方式
          # threading.Thread(
          #     target=account.deposit, args=(1, )
          # ).start()
          # 创建线程的第2种方式
          # AddMoneyThread(account, 1).start()
          # 创建线程的第3种方式
          # 调用线程池中的线程来执行特定的任务
          future = pool.submit(account.deposit, 1)
          futures.append(future)
      # 关闭线程池
      pool.shutdown()
      for future in futures:
          future.result()
      print(account.balance)
  
  
  if __name__ == '__main__':
      main()
  ```

  修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用`threading`模块的`Condition`来实现线程调度，该对象也是基于锁来创建的，代码如下所示：

  ```Python
  """
  多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）
  多个线程竞争多个资源（线程数>资源数） - 信号量（Semaphore）
  多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition
  """
  from concurrent.futures import ThreadPoolExecutor
  from random import randint
  from time import sleep
  
  import threading
  
  
  class Account:
      """银行账户"""
  
      def __init__(self, balance=0):
          self.balance = balance
          lock = threading.RLock()
          self.condition = threading.Condition(lock)
  
      def withdraw(self, money):
          """取钱"""
          with self.condition:
              while money > self.balance:
                  self.condition.wait()
              new_balance = self.balance - money
              sleep(0.001)
              self.balance = new_balance
  
      def deposit(self, money):
          """存钱"""
          with self.condition:
              new_balance = self.balance + money
              sleep(0.001)
              self.balance = new_balance
              self.condition.notify_all()
  
  
  def add_money(account):
      while True:
          money = randint(5, 10)
          account.deposit(money)
          print(threading.current_thread().name, 
                ':', money, '====>', account.balance)
          sleep(0.5)
  
  
  def sub_money(account):
      while True:
          money = randint(10, 30)
          account.withdraw(money)
          print(threading.current_thread().name, 
                ':', money, '<====', account.balance)
          sleep(1)
  
  
  def main():
      account = Account()
      with ThreadPoolExecutor(max_workers=15) as pool:
          for _ in range(5):
              pool.submit(add_money, account)
          for _ in range(10):
              pool.submit(sub_money, account)
  
  
  if __name__ == '__main__':
      main()
  ```

- 多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是`Process`，其他辅助的类跟`threading`模块中的类似，进程间共享数据可以使用管道、套接字等，在`multiprocessing`模块中有一个`Queue`类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。

  ```Python
  """
  多进程和进程池的使用
  多线程因为GIL的存在不能够发挥CPU的多核特性
  对于计算密集型任务应该考虑使用多进程
  time python3 example22.py
  real    0m11.512s
  user    0m39.319s
  sys     0m0.169s
  使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍
  这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU
  """
  import concurrent.futures
  import math
  
  PRIMES = [
      1116281,
      1297337,
      104395303,
      472882027,
      533000389,
      817504243,
      982451653,
      112272535095293,
      112582705942171,
      112272535095293,
      115280095190773,
      115797848077099,
      1099726899285419
  ] * 5
  
  
  def is_prime(n):
      """判断素数"""
      if n % 2 == 0:
          return False
  
      sqrt_n = int(math.floor(math.sqrt(n)))
      for i in range(3, sqrt_n + 1, 2):
          if n % i == 0:
              return False
      return True
  
  
  def main():
      """主函数"""
      with concurrent.futures.ProcessPoolExecutor() as executor:
          for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):
              print('%d is prime: %s' % (number, prime))
  
  
  if __name__ == '__main__':
      main()
  ```

  > **重点**：**多线程和多进程的比较**。
  >
  > 以下情况需要使用多线程：
  >
  > 1. 程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。
  > 2. 程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。
  >
  > 以下情况需要使用多进程：
  >
  > 1. 程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。
  > 2. 程序的输入可以并行的分成块，并且可以将运算结果合并。
  > 3. 程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。

- 异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者`future`对象来获取任务执行的结果。Python 3通过`asyncio`模块和`await`和`async`关键字（在Python 3.7中正式被列为关键字）来支持异步处理。

  ```Python
  """
  异步I/O - async / await
  """
  import asyncio
  
  
  def num_generator(m, n):
      """指定范围的数字生成器"""
      yield from range(m, n + 1)
  
  
  async def prime_filter(m, n):
      """素数过滤器"""
      primes = []
      for i in num_generator(m, n):
          flag = True
          for j in range(2, int(i ** 0.5 + 1)):
              if i % j == 0:
                  flag = False
                  break
          if flag:
              print('Prime =>', i)
              primes.append(i)
  
          await asyncio.sleep(0.001)
      return tuple(primes)
  
  
  async def square_mapper(m, n):
      """平方映射器"""
      squares = []
      for i in num_generator(m, n):
          print('Square =>', i * i)
          squares.append(i * i)
  
          await asyncio.sleep(0.001)
      return squares
  
  
  def main():
      """主函数"""
      loop = asyncio.get_event_loop()
      future = asyncio.gather(prime_filter(2, 100), square_mapper(1, 100))
      future.add_done_callback(lambda x: print(x.result()))
      loop.run_until_complete(future)
      loop.close()
  
  
  if __name__ == '__main__':
      main()
  ```

  > **说明**：上面的代码使用`get_event_loop`函数获得系统默认的事件循环，通过`gather`函数可以获得一个`future`对象，`future`对象的`add_done_callback`可以添加执行完成时的回调函数，`loop`对象的`run_until_complete`方法可以等待通过`future`对象获得协程执行结果。

  Python中有一个名为`aiohttp`的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟`asyncio`模块一起工作，并提供了对`Future`对象的支持。Python 3.6中引入了`async`和`await`来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。

  ```Python
  import asyncio
  import re
  
  import aiohttp
  
  PATTERN = re.compile(r'\<title\>(?P<title>.*)\<\/title\>')
  
  
  async def fetch_page(session, url):
      async with session.get(url, ssl=False) as resp:
          return await resp.text()
  
  
  async def show_title(url):
      async with aiohttp.ClientSession() as session:
          html = await fetch_page(session, url)
          print(PATTERN.search(html).group('title'))
  
  
  def main():
      urls = ('https://www.python.org/',
              'https://git-scm.com/',
              'https://www.jd.com/',
              'https://www.taobao.com/',
              'https://www.douban.com/')
      loop = asyncio.get_event_loop()
      cos = [show_title(url) for url in urls]
      loop.run_until_complete(asyncio.wait(cos))
      loop.close()
  
  
  if __name__ == '__main__':
      main()
  ```

  > **重点**：**异步I/O与多进程的比较**。
  >
  > 当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，`asyncio`就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑`asyncio`，它很适合编写没有实时数据处理需求的Web应用服务器。

  Python还有很多用于处理并行任务的三方库，例如：`joblib`、`PyMP`等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。

  要实现任务的异步化，可以使用名为`Celery`的三方库。`Celery`是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。